---
title: "2 R basics"
output:
  html_document:
    df_print: paged
    css: "style.css"
    toc: true
---

[Book](http://rafalab.dfci.harvard.edu/dsbook/r-basics.html)

# 2.2 The very basics

<span class="hl2">Hello</span> `ls()`

```{r}
ls()
```

If you want a quick look at the arguments without opening the help system, you can type: `args(function)`

```{r}
args(log)
```

You can see all the available datasets by typing `data()`

```{r}
data()
```

This shows you the object name for these datasets. These datasets are objects that can be used by simply typing the name. For example, if you type:

```{r}
co2
```

R will show you Mauna Loa atmospheric CO2 concentration data.

**Motivating scripts**

```{r}
a <- 3
b <- 2
c <- -1
(-b + sqrt(b^2 - 4*a*c)) / (2*a)
(-b - sqrt(b^2 - 4*a*c)) / (2*a)
```

# 2.4 Data types

Print class of object `class(object)`

```{r}
a <- 2
class(a)
```

## 2.4.1 Data frames

Load dataset `data()`

```{r}
# install.packages("dslabs")
library(dslabs)
data(murders)
```

```{r}
class(murders)
```

## 2.4.2 Examining an object

`str()` Object structure

```{r}
str(murders)
```

`names()` Variable (column) names

```{r}
names(murders)
```

`head()`

```{r}
head(murders)
```

## 2.4.3 The accessor: `$`

```{r}
murders$population
```

## 2.4.4 Vectors: numerics, characters, and logical

The object murders$population is not one number but several. We call these types of objects vectors. A single number is technically a vector of length 1, but in general we use the term vectors to refer to objects with several entries. 

`length()` tells you how many entries are in the vector:

```{r}
pop <- murders$population
length(pop)
```

```{r}
class(pop)
```

```{r}
class(murders$state)
```

```{r}
z <- 3 == 2
z
```
```{r}
class(z)
```

Mathematically, the values in pop are integers and there is an integer class in R. However, by default, numbers are assigned class numeric even when they are round integers. For example, class(1) returns numeric. <span class="hl2">You can turn them into class integer with the **`as.integer()`** function or by adding an L like this: 1L. Note the class by typing: class(1L)</span>

2.4.5 Factors

```{r}
class(murders$region)
```

`levels()`

```{r}
levels(murders$region)
```

In the background, R stores these levels as integers and keeps a map to keep track of the labels. This is more memory efficient than storing all the characters.

`reorder()` change the order of levels

For example, in the murders dataset regions are ordered from east to west. The function reorder lets us change the order of the levels of a factor variable based on a summary computed on a numeric vector. We will demonstrate this with a simple example, and will see more advanced ones in the Data Visualization part of the book.

<span class="hl2">Suppose we want the levels of the region by the total number of murders rather than alphabetical order.</span> If there are values associated with each level, we can use the reorder and specify a data summary to determine the order. The following code takes the sum of the total murders in each region, and reorders the factor following these sums

```{r}
region <- murders$region
value <- murders$total
region <- reorder(region, value, FUN = sum)
levels(region)
```

The new order is in agreement with the fact that the Northeast has the least murders and the South has the most.

**Warning**: Factors can be a source of confusion since sometimes they behave like characters and sometimes they do not. As a result, confusing factors and characters are a common source of bugs.

## 2.4.6 Lists

`list()`

```{r}
record <- list(
  name = "John Doe",
  student_id = 1234,
  grades = c(95, 82, 91, 97, 93),
  final_grade = "A"
)
record
```

Double-square bracket accessor

Useful for lists without variable names

```{r}
record2 <- list("John Doe", 1234)
record2
```

```{r}
record2[[1]]
```

## 2.4.7 Matrices

Matrices are another type of object that are common in R. Matrices are similar to data frames in that they are two-dimensional: they have rows and columns. However, <span class="hl2">like numeric, character and logical vectors, entries in matrices have to be all the same type. </span> For this reason data frames are much more useful for storing data, since we can have characters, factors, and numbers in them.

<span class="hl2>Yet matrices have a major advantage over data frames: we can perform matrix algebra operations,</span> a powerful type of mathematical technique. We do not describe these operations in this book, but much of what happens in the background when you perform a data analysis involves matrices. We only cover matrices briefly here since some of the functions we will learn return matrices. However, if you plan to perform more advanced work, we highly recommend learning more as they are widely used in data analysis.

`matrix(data, num_rows, num_cols) define a matrix with

```{r}
mat <- matrix(1:12, 4, 3)
mat
```

```{r}
mat[2, 3]
```

leave the column spot empty to select entire row and vice versa:

```{r}
mat[2,]
```
```{r}
mat[, 3]
```

Notice that these return vectors not matrices

```{r}
class(mat[,3])
```

Slicing matrices

These return matrices

```{r}
mat[, 2:3]
```

```{r}
mat[1:2, 2:3]
```

Convert matrices to data frames `as.data.frame()`
```{r}
as.data.frame(mat)
```

You can also use single square brackets ([) to access rows and columns of a data frame

```{r}
data("murders")
murders[25, 1]
```

```{r}
murders[2:3, ]
```

# 2.5 Exercises

1. Load the US murders dataset.

library(dslabs)
data(murders)

Use the function str to examine the structure of the murders object. 

```{r}
str(murders)
```

Which of the following best describes the variables represented in this data frame?
  a. The 51 states.
  b. The murder rates for all 50 states and DC.
  c. The state name, the abbreviation of the state name, the state’s region, and the state’s population and total number of murders for 2010.
  d. str shows no relevant information.
  
2. What are the column names used by the data frame for these five variables?

```{r}
names(murders)
```


3. Use the accessor $ to extract the state abbreviations and assign them to the object a. What is the class of this object?

```{r}
a <- murders$abb
class(a)
```


4. Now use the square brackets to extract the state abbreviations and assign them to the object b. Use the identical function to determine if a and b are the same.

```{r}
b <- murders[["abb"]]
identical(a, b)
```


5. We saw that the region column stores a factor. You can corroborate this by typing:

class(murders$region)
With one line of code, use the function levels and length to determine the number of regions defined by this dataset.

```{r}
length(levels(murders$region))
```


6. The function table takes a vector and returns the frequency of each element. You can quickly see how many states are in each region by applying this function. Use this function in one line of code to create a table of states per region.

`table()` returns frequency of each element

```{r}
table(murders$region)
```

## 2.6.1 Creating vectors

`c()` stands for *concatenate*

```{r}
codes <- c(380, 124, 818)
codes
```


```{r}
country <- c("italy", "canada", "egypt")
country
```

## 2.6.2 Names

Assign names to vector entries. `""` are optional for names.

```{r}
codes <- c(italy = 380, canada = 124, egypt = 818)
codes
```
```{r}
class(codes)
```
```{r}
names(codes)
```

<span class="hl2">Assign names with `names()`</span>

```{r}
country <- c("italy", "canada", "egypt")
codes <- c(380, 124, 818)
names(codes) <- country
codes
```

## 2.6.3 Sequences

`seq(start, end, skip)` to generate vectors

```{r}
seq(1, 10, 2)
```

**Shorthand for vector creation**

```{r}
1:10
```

When we use these functions, R produces integers, not numerics, because they are typically used to index something:

```{r}
class(1:10)
```

However, if we create a sequence including non-integers, the class changes:

```{r}
class(seq(1, 10, 0.5))
```

## 2.6.4 Subsetting

```{r}
codes[2]
```
```{r}
codes[c(1, 3)]
```
```{r}
codes[1:2]
```
```{r}
codes["canada"]
```
```{r}
codes[c("egypt","italy")]
```

## 2.7 Corecion







