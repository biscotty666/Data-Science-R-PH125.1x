---
title: "2 R basics"
output:
  html_document:
    df_print: paged
    css: "style.css"
    toc: true
---

[Book](http://rafalab.dfci.harvard.edu/dsbook/r-basics.html)

# 2.2 The very basics

<span class="hl2">Hello</span> `ls()`

```{r}
ls()
```

If you want a quick look at the arguments without opening the help system, you can type: `args(function)`

```{r}
args(log)
```

You can see all the available datasets by typing `data()`

```{r}
data()
```

This shows you the object name for these datasets. These datasets are objects that can be used by simply typing the name. For example, if you type:

```{r}
co2
```

R will show you Mauna Loa atmospheric CO2 concentration data.

**Motivating scripts**

```{r}
a <- 3
b <- 2
c <- -1
(-b + sqrt(b^2 - 4*a*c)) / (2*a)
(-b - sqrt(b^2 - 4*a*c)) / (2*a)
```

# 2.4 Data types

Print class of object `class(object)`

```{r}
a <- 2
class(a)
```

## 2.4.1 Data frames

Load dataset `data()`

```{r}
# install.packages("dslabs")
library(dslabs)
data(murders)
```

```{r}
class(murders)
```

## 2.4.2 Examining an object

`str()` Object structure

```{r}
str(murders)
```

`names()` Variable (column) names

```{r}
names(murders)
```

`head()`

```{r}
head(murders)
```

## 2.4.3 The accessor: `$`

```{r}
murders$population
```

## 2.4.4 Vectors: numerics, characters, and logical

The object murders$population is not one number but several. We call these types of objects vectors. A single number is technically a vector of length 1, but in general we use the term vectors to refer to objects with several entries. 

`length()` tells you how many entries are in the vector:

```{r}
pop <- murders$population
length(pop)
```

```{r}
class(pop)
```

```{r}
class(murders$state)
```

```{r}
z <- 3 == 2
z
```
```{r}
class(z)
```

Mathematically, the values in pop are integers and there is an integer class in R. However, by default, numbers are assigned class numeric even when they are round integers. For example, class(1) returns numeric. <span class="hl2">You can turn them into class integer with the **`as.integer()`** function or by adding an L like this: 1L. Note the class by typing: class(1L)</span>

2.4.5 Factors

```{r}
class(murders$region)
```

`levels()`

```{r}
levels(murders$region)
```

In the background, R stores these levels as integers and keeps a map to keep track of the labels. This is more memory efficient than storing all the characters.

`reorder()` change the order of levels

For example, in the murders dataset regions are ordered from east to west. The function reorder lets us change the order of the levels of a factor variable based on a summary computed on a numeric vector. We will demonstrate this with a simple example, and will see more advanced ones in the Data Visualization part of the book.

<span class="hl2">Suppose we want the levels of the region by the total number of murders rather than alphabetical order.</span> If there are values associated with each level, we can use the reorder and specify a data summary to determine the order. The following code takes the sum of the total murders in each region, and reorders the factor following these sums

```{r}
region <- murders$region
value <- murders$total
region <- reorder(region, value, FUN = sum)
levels(region)
```

The new order is in agreement with the fact that the Northeast has the least murders and the South has the most.

**Warning**: Factors can be a source of confusion since sometimes they behave like characters and sometimes they do not. As a result, confusing factors and characters are a common source of bugs.

## 2.4.6 Lists

`list()`

```{r}
record <- list(
  name = "John Doe",
  student_id = 1234,
  grades = c(95, 82, 91, 97, 93),
  final_grade = "A"
)
record
```

Double-square bracket accessor

Useful for lists without variable names

```{r}
record2 <- list("John Doe", 1234)
record2
```

```{r}
record2[[1]]
```

## 2.4.7 Matrices

Matrices are another type of object that are common in R. Matrices are similar to data frames in that they are two-dimensional: they have rows and columns. However, <span class="hl2">like numeric, character and logical vectors, entries in matrices have to be all the same type. </span> For this reason data frames are much more useful for storing data, since we can have characters, factors, and numbers in them.

<span class="hl2>Yet matrices have a major advantage over data frames: we can perform matrix algebra operations,</span> a powerful type of mathematical technique. We do not describe these operations in this book, but much of what happens in the background when you perform a data analysis involves matrices. We only cover matrices briefly here since some of the functions we will learn return matrices. However, if you plan to perform more advanced work, we highly recommend learning more as they are widely used in data analysis.

`matrix(data, num_rows, num_cols) define a matrix with

```{r}
mat <- matrix(1:12, 4, 3)
mat
```

```{r}
mat[2, 3]
```

leave the column spot empty to select entire row and vice versa:

```{r}
mat[2,]
```
```{r}
mat[, 3]
```

Notice that these return vectors not matrices

```{r}
class(mat[,3])
```

Slicing matrices

These return matrices

```{r}
mat[, 2:3]
```

```{r}
mat[1:2, 2:3]
```

Convert matrices to data frames `as.data.frame()`
```{r}
as.data.frame(mat)
```

You can also use single square brackets ([) to access rows and columns of a data frame

```{r}
data("murders")
murders[25, 1]
```

```{r}
murders[2:3, ]
```

# 2.5 Exercises

1. Load the US murders dataset.

library(dslabs)
data(murders)

Use the function str to examine the structure of the murders object. 

```{r}
str(murders)
```

Which of the following best describes the variables represented in this data frame?
  a. The 51 states.
  b. The murder rates for all 50 states and DC.
  c. The state name, the abbreviation of the state name, the state’s region, and the state’s population and total number of murders for 2010.
  d. str shows no relevant information.
  
2. What are the column names used by the data frame for these five variables?

```{r}
names(murders)
```


3. Use the accessor $ to extract the state abbreviations and assign them to the object a. What is the class of this object?

```{r}
a <- murders$abb
class(a)
```


4. Now use the square brackets to extract the state abbreviations and assign them to the object b. Use the identical function to determine if a and b are the same.

```{r}
b <- murders[["abb"]]
identical(a, b)
```


5. We saw that the region column stores a factor. You can corroborate this by typing:

class(murders$region)
With one line of code, use the function levels and length to determine the number of regions defined by this dataset.

```{r}
length(levels(murders$region))
```


6. The function table takes a vector and returns the frequency of each element. You can quickly see how many states are in each region by applying this function. Use this function in one line of code to create a table of states per region.

`table()` returns frequency of each element

```{r}
table(murders$region)
```


# 2.6 Vectors

## 2.6.1 Creating vectors

`c()` stands for *concatenate*

```{r}
codes <- c(380, 124, 818)
codes
```


```{r}
country <- c("italy", "canada", "egypt")
country
```

## 2.6.2 Names

Assign names to vector entries. `""` are optional for names.

```{r}
codes <- c(italy = 380, canada = 124, egypt = 818)
codes
```
```{r}
class(codes)
```
```{r}
names(codes)
```

<span class="hl2">Assign names with `names()`</span>

```{r}
country <- c("italy", "canada", "egypt")
codes <- c(380, 124, 818)
names(codes) <- country
codes
```

## 2.6.3 Sequences

`seq(start, end, skip)` to generate vectors

```{r}
seq(1, 10, 2)
```

**Shorthand for vector creation**

```{r}
1:10
```

When we use these functions, R produces integers, not numerics, because they are typically used to index something:

```{r}
class(1:10)
```

However, if we create a sequence including non-integers, the class changes:

```{r}
class(seq(1, 10, 0.5))
```

## 2.6.4 Subsetting

```{r}
codes[2]
```
```{r}
codes[c(1, 3)]
```
```{r}
codes[1:2]
```
```{r}
codes["canada"]
```
```{r}
codes[c("egypt","italy")]
```

# 2.7 Coercion

In general, coercion is an attempt by R to be flexible with data types. When an entry does not match the expected, some of the prebuilt R functions try to guess what was meant before throwing an error. This can also lead to confusion. Failing to understand coercion can drive programmers crazy when attempting to code in R since it behaves quite differently from most other languages in this regard. Let’s learn about it with some examples.

```{r}
x <- c(1, "canada", 3)
class(x)
```

R coerced the data into characters. 

Changing data types

```{r}
x <- 1:5
y <- as.character(x)
y
```
```{r}
as.numeric(y)
```

## 2.7.1 Not availables (NA)

```{r}
x <- c("1", "b", "3")
as.numeric(x)
```

# 2.8 Exercises

1. Use the function c to create a vector with the average high temperatures in January for Beijing, Lagos, Paris, Rio de Janeiro, San Juan, and Toronto, which are 35, 88, 42, 84, 81, and 30 degrees Fahrenheit. Call the object temp.

```{r}
temp <- c(35,88,42,84,81,30)
```

2. Now create a vector with the city names and call the object city.

```{r}
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro", "San Juan", "Toronto")
```

3. Use the names function and the objects defined in the previous exercises to associate the temperature data with its corresponding city.

```{r}
names(temp) <- city
```
```{r}
temp
```

4. Use the [ and : operators to access the temperature of the first three cities on the list.

```{r}
temp[1:3]
```

5. Use the [ operator to access the temperature of Paris and San Juan.

```{r}
temp[c("Paris", "San Juan")]
```

6. Use the : operator to create a sequence of numbers $12,13,14,\dots,73$.

```{r}
a <- 12:73
a
```

7. Create a vector containing all the positive odd numbers smaller than 100.

```{r}
b <- seq(1, 99, 2)
b
```

8. Create a vector of numbers that starts at 6, does not pass 55, and adds numbers in increments of 4/7: 6, 6 + 4/7, 6 + 8/7, and so on. How many numbers does the list have? Hint: use seq and length.

```{r}
c <- seq(6,55-.001,4/7)
length(c)
```

9. What is the class of the following object a <- seq(1, 10, 0.5)?

```{r}
a <- seq(1, 10, 0.5)
class(a)
```

10. What is the class of the following object a <- seq(1, 10)?

```{r}
class(seq(1, 10))
```

11. The class of class(a<-1) is numeric, not integer. R defaults to numeric and to force an integer, you need to add the letter L. Confirm that the class of 1L is integer.

```{r}
class(1L)
```

12. Define the following vector:

x <- c("1", "3", "5")
and coerce it to get integers.

```{r}
x <- c("1","3","5")
as.numeric(x)
```

# 2.9 Sorting

Now that we have mastered some basic R knowledge, let’s try to gain some insights into the safety of different states in the context of gun murders.

## 2.9.1 `sort()`

Say we want to rank the states from least to most gun murders. The function sort sorts a vector in increasing order. We can therefore see the largest number of gun murders by typing:

```{r}
library(dslabs)
data(murders)
sort(murders$total)
```

## 2.9.2 `order()`

Takes a vector as input and returns the vector of indexes that sorts the input vector. 

```{r}
x <- c(31, 4, 15, 92, 65)
sort(x)
```

```{r}
index <- order(x)
index
```
```{r}
x[index]
```

How does this help us order the states by murders? First, remember that the entries of vectors you access with $ follow the same order as the rows in the table. For example, these two vectors containing state names and abbreviations, respectively, are matched by their order:

```{r}
ind <- order(murders$total)
murders$abb[ind]
```

## 2.9.3 `max` and `which.max`

```{r}
max(murders$total)
```

`which.max()` returns the index of the largest value

```{r}
i_max <- which.max(murders$total)
murders$state[i_max]
```

## 2.9.4 `rank()`

```{r}
x <- c(31, 4, 15, 92, 65)
rank(x)
```

## 2.9.5 Beware of recycling

Another common source of unnoticed errors in R is the use of recycling. We saw that vectors are added elementwise. So if the vectors don’t match in length, it is natural to assume that we should get an error. But we don’t. Notice what happens:

```{r}
x <- c(1, 2, 3)
y <- c(10, 20, 30, 40, 50, 60, 70)
x + y
```

We do get a warning, but no error. For the output, <span class="hl2">R has recycled the numbers in `x`</span>. Notice the last digit of numbers in the output.

# 2.10 Exercises

For these exercises we will use the US murders dataset. Make sure you load it prior to starting.

library(dslabs)
data("murders")

1. Use the $ operator to access the population size data and store it as the object pop. Then use the sort function to redefine pop so that it is sorted. Finally, use the [ operator to report the smallest population size.

```{r}
pop <- murders$population
pop_s <- sort(pop)
pop_s[1]
```

2. Now instead of the smallest population size, find the index of the entry with the smallest population size. Hint: use order instead of sort.

```{r}
index <- order(pop)
index[1]
```

3. We can actually perform the same operation as in the previous exercise using the function which.min. Write one line of code that does this.

```{r}
which.min(pop)
```

4. Now we know how small the smallest state is and we know which row represents it. Which state is it? Define a variable states to be the state names from the murders data frame. Report the name of the state with the smallest population.

```{r}
state_names <- murders$state
state_names[which.min(pop)]
```

5. You can create a data frame using the `data.frame` function. Here is a quick example:

**`data.frame()`**

```{r}
temp <- c(35, 88, 42, 84, 81, 30)
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro", 
          "San Juan", "Toronto")
city_temps <- data.frame(name = city, temperature = temp)
city_temps
```

Use the rank function to determine the population rank of each state from smallest population size to biggest. Save these ranks in an object called ranks, then create a data frame with the state name and its rank. Call the data frame my_df.

```{r}
ranks <- rank(pop)
ranks
```
```{r}
my_df <- data.frame(name = state_names, rank = ranks)
my_df
```

6. Repeat the previous exercise, but this time order my_df so that the states are ordered from least populous to most populous. Hint: create an object ind that stores the indexes needed to order the population values. Then use the bracket operator [ to re-order each column in the data frame.

```{r}
sort(my_df$rank)
```


7. The na_example vector represents a series of counts. You can quickly examine the object using:

```{r}
data("na_example")  
str(na_example)
```

However, when we compute the average with the function mean, we obtain an NA:

```{r}
mean(na_example)
```

The is.na function returns a logical vector that tells us which entries are NA. Assign this logical vector to an object called ind and determine how many NAs does na_example have.

```{r}
ind <- is.na(na_example)
length(ind)
```


8. Now compute the average again, but only for the entries that are not NA. Hint: remember the ! operator.

```{r}
mean(na_example, na.rm = TRUE)
```













